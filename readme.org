#+TITLE: 操作系统
#+AUTHOR: Jinghui Hu
#+EMAIL: hujinghui@buaa.edu.cn
#+DATE: <2023-06-17 Sat 21:28:48>
#+STARTUP: overview num indent


* 汇编及体系结构
** 8086 体系结构
*** 概述
8086 是 16 位的体系结构，采用小端的存储方式
** 实模式
*** 寄存器
| 分类         | 名称 | 全称                |
|--------------+------+---------------------|
| 通用寄存器   | AX   | Accumulator         |
| 通用寄存器   | BX   | Base                |
| 通用寄存器   | CX   | Counter             |
| 通用寄存器   | DX   | Data                |
| 指针寄存器   | SP   | Stack Pointer       |
| 指针寄存器   | BP   | Base Pointer        |
| 变地址寄存器 | SI   | Source Index        |
| 变地址寄存器 | DI   | Destination Index   |
| 控制寄存器   | IP   | Instruction Pointer |
| 控制寄存器   | FLAG | Flag                |
| 段寄存器     | CS   | Code Segment        |
| 段寄存器     | DS   | Data Segment        |
| 段寄存器     | SS   | Stack Segment       |
| 段寄存器     | ES   | Extra Segment       |
*** 栈 bp, sp
1. sp 指向栈的顶端 stack pointer
2. bp 指向栈的基地址 base pointer
3. push 操作时, sp = sp - 2, bp 不变
4. pop 操作时, sp = sp + 2, bp 不变

#+BEGIN_SRC asm
  .code16                         ; 16 bits mode

  ;;; 初始化栈指针
  mov bp, 0x8000
  mov sp, bp                      ; sp = bp 时, 栈为空

  ;;; 压入 3 个测试数据
  ;;; sp = 0x8000, bp = 0x8000
  push 'A'
  ;;; sp = 0x7ffe, bp = 0x8000
  push 'B'
  ;;; sp = 0x7ffc, bp = 0x8000
  push 'C'

  ;;; 查看数据
  mov bx, bp
  mov al, [bx-2]
  int 0x10                        ; 打印 A

  mov bx, spp
  mov al, [bx]
  int 0x10                        ; 打印 C

  ;;; 弹出数据
  pop bx
  ;;; sp = 0x7ffc, bp = 0x8000
  mov al, bl
  int 0x10                        ; 打印 C

  pop bx
  ;;; sp = 0x7ffe, bp = 0x8000
  mov al, bl
  int 0x10                        ; 打印 B

  pop bx
  ;;; sp = 0x8000, bp = 0x8000
  mov al, bl
  int 0x10                        ; 打印 A
#+END_SRC

*** 分支
~jmp $~, $ 表示当前标号, 该指令会死循环

通常汇编的跳转通过 ~cmp~, ~je~, ~jmp~ 等指令配合实现，例如
#+BEGIN_SRC asm
  cmp ax, 4      ; if ax = 4
  je ax_is_four  ; do something (by jumping to that label)
  jmp else       ; else, do another thing
  jmp endif      ; finally, resume the normal flow

  ax_is_four:
      .....
      jmp endif

  else:
      .....
      jmp endif  ; not actually necessary but printed here for completeness

  endif:
#+END_SRC

函数调用也属于简单的跳转指令, 例如
#+BEGIN_SRC asm
  mov al, 'X'
  jmp print
  endprint:

  print:
      mov ah, 0x0e                ; tty code
      int 0x10                    ; 打印 al 的字符
      jmp endprint                ; 返回
#+END_SRC

由于函数调用非常常见, 会有一些指令来简化函数调用实现过程
#+BEGIN_SRC asm
  mov al, 'X'
  call print

  print:
      mov ah, 0x0e                ; tty code
      int 0x10                    ; 打印 al 的字符
      ret
#+END_SRC

*** 分段
8086 寄存器是 16 位的, 真实地址 = 段地址 << 4 + address
#+BEGIN_SRC asm
  ;;; 设置 ds 段寄存器
  mov bx, 0x7c0
  mov ds, bx
  ;;; 默认使用 ds 段寄存器作为基地址
  mov al, [msg]
  int 0x10

  ;;; 使用 es 段寄存器进行寻址
  mov bx, 0x7c0
  mov es, bx
  mov al, [es:the_secret]
  int 0x10
#+END_SRC
*** 磁盘
读取磁盘的指令需要将 ~al~ 设置成 ~0x02~ , 其他寄存器设置 cylinder, head 和
sector, 然后调用中断 ~int 0x13~, 其中详细的中断参数见 [[https://stanislavs.org/helppc/int_13-2.html][link]]
#+BEGIN_SRC text
  AH = 02
  AL = number of sectors to read	(1-128 dec.)
  CH = track/cylinder number  (0-1023 dec., see below)
  CL = sector number  (1-17 dec.)
  DH = head number  (0-15 dec.)
  DL = drive number (0=A:, 1=2nd floppy, 80h=drive 0, 81h=drive 1)
  ES:BX = pointer to buffer


  on return:
  AH = status  (see INT 13,STATUS)
  AL = number of sectors read
  CF = 0 if successful
     = 1 if error


  - BIOS disk reads should be retried at least three times and the
    controller should be reset upon error detection
  - be sure ES:BX does not cross a 64K segment boundary or a
    DMA boundary error will occur
  - many programming references list only floppy disk register values
  - only the disk number is checked for validity
  - the parameters in CX change depending on the number of cylinders;
    the track/cylinder number is a 10 bit value taken from the 2 high
    order bits of CL and the 8 bits in CH (low order 8 bits of track):

    |F|E|D|C|B|A|9|8|7|6|5-0|  CX
     | | | | | | | | | |	`-----	sector number
     | | | | | | | | `---------  high order 2 bits of track/cylinder
     `------------------------  low order 8 bits of track/cyl number
#+END_SRC

~carry bit~ 是用来记录操作是否溢出，例如
#+BEGIN_SRC asm
  mov ax, 0xFFFF
  add ax, 1                       ; ax = 0x0000 and carry = 1, 设置了溢出位
  jc label                        ; 如果溢出位设置了则跳转
#+END_SRC
** 保护模式
*** 适配 BIOS
*** GDT

** 书籍及配套教材
1. 《x86 汇编语言：从实模式到保护模式》 [[http://www.lizhongc.com/index.php/archives/10/][book]] | [[https://www.bilibili.com/video/BV1xE411N74T/?spm_id_from=333.337.search-card.all.click&vd_source=3a56932406d5df288a20eff532848982][video]] | [[http://www.lizhongc.com/][李忠]]

* Linux 0.11
** MacOS
#+BEGIN_SRC sh
  brew install i386-elf-binutils i386-elf-gcc
#+END_SRC
