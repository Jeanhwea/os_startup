#+TITLE: 操作系统
#+AUTHOR: Jinghui Hu
#+EMAIL: hujinghui@buaa.edu.cn
#+DATE: <2023-06-17 Sat 21:28:48>
#+STARTUP: overview num indent


* 汇编及体系结构
** 8086 体系结构
*** 概述
8086 是 16 位的体系结构，采用小端的存储方式
*** 寄存器
| 分类         | 名称 | 全称                |
|--------------+------+---------------------|
| 通用寄存器   | AX   | Accumulator         |
| 通用寄存器   | BX   | Base                |
| 通用寄存器   | CX   | Counter             |
| 通用寄存器   | DX   | Data                |
| 指针寄存器   | SP   | Stack Pointer       |
| 指针寄存器   | BP   | Base Pointer        |
| 变地址寄存器 | SI   | Source Index        |
| 变地址寄存器 | DI   | Destination Index   |
| 控制寄存器   | IP   | Instruction Pointer |
| 控制寄存器   | FLAG | Flag                |
| 段寄存器     | CS   | Code Segment        |
| 段寄存器     | DS   | Data Segment        |
| 段寄存器     | SS   | Stack Segment       |
| 段寄存器     | ES   | Extra Segment       |
*** 栈 bp, sp
1. sp 指向栈的顶端 stack pointer
2. bp 指向栈的基地址 base pointer
3. push 操作时, sp = sp - 2, bp 不变
4. pop 操作时, sp = sp + 2, bp 不变

#+BEGIN_SRC asm
  .code16                         ; 16 bits mode

  ;;; 初始化栈指针
  mov bp, 0x8000
  mov sp, bp                      ; sp = bp 时, 栈为空

  ;;; 压入 3 个测试数据
  ;;; sp = 0x8000, bp = 0x8000
  push 'A'
  ;;; sp = 0x7ffe, bp = 0x8000
  push 'B'
  ;;; sp = 0x7ffc, bp = 0x8000
  push 'C'

  ;;; 查看数据
  mov bx, bp
  mov al, [bx-2]
  int 0x10                        ; 打印 A

  mov bx, spp
  mov al, [bx]
  int 0x10                        ; 打印 C

  ;;; 弹出数据
  pop bx
  ;;; sp = 0x7ffc, bp = 0x8000
  mov al, bl
  int 0x10                        ; 打印 C

  pop bx
  ;;; sp = 0x7ffe, bp = 0x8000
  mov al, bl
  int 0x10                        ; 打印 B

  pop bx
  ;;; sp = 0x8000, bp = 0x8000
  mov al, bl
  int 0x10                        ; 打印 A
#+END_SRC

*** 控制流及函数调用
~jmp $~, $ 表示当前标号, 该指令会死循环

通常汇编的跳转通过 ~cmp~, ~je~, ~jmp~ 等指令配合实现，例如
#+BEGIN_SRC asm
  cmp ax, 4      ; if ax = 4
  je ax_is_four  ; do something (by jumping to that label)
  jmp else       ; else, do another thing
  jmp endif      ; finally, resume the normal flow

  ax_is_four:
      .....
      jmp endif

  else:
      .....
      jmp endif  ; not actually necessary but printed here for completeness

  endif:
#+END_SRC

函数调用也属于简单的跳转指令, 例如
#+BEGIN_SRC asm
  mov al, 'X'
  jmp print
  endprint:

  print:
      mov ah, 0x0e                ; tty code
      int 0x10                    ; 打印 al 的字符
      jmp endprint                ; 返回
#+END_SRC

由于函数调用非常常见, 会有一些指令来简化函数调用实现过程
#+BEGIN_SRC asm
  mov al, 'X'
  call print

  print:
      mov ah, 0x0e                ; tty code
      int 0x10                    ; 打印 al 的字符
      ret
#+END_SRC

** 书籍及配套教材
1. 《x86 汇编语言：从实模式到保护模式》 [[http://www.lizhongc.com/index.php/archives/10/][book]] | [[https://www.bilibili.com/video/BV1xE411N74T/?spm_id_from=333.337.search-card.all.click&vd_source=3a56932406d5df288a20eff532848982][video]] | [[http://www.lizhongc.com/][李忠]]

* Linux 0.11
** MacOS
#+BEGIN_SRC sh
  brew install i386-elf-binutils i386-elf-gcc
#+END_SRC
