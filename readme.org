#+TITLE: 操作系统
#+AUTHOR: Jinghui Hu
#+EMAIL: hujinghui@buaa.edu.cn
#+DATE: <2023-06-17 Sat 21:28:48>
#+STARTUP: overview num indent


* 汇编及体系结构
** 8086 体系结构
*** 概述
8086 是 16 位的体系结构，采用小端的存储方式
** 实模式
*** 寄存器
| 分类         | 名称 | 全称                |
|--------------+------+---------------------|
| 通用寄存器   | AX   | Accumulator         |
| 通用寄存器   | BX   | Base                |
| 通用寄存器   | CX   | Counter             |
| 通用寄存器   | DX   | Data                |
| 指针寄存器   | SP   | Stack Pointer       |
| 指针寄存器   | BP   | Base Pointer        |
| 变地址寄存器 | SI   | Source Index        |
| 变地址寄存器 | DI   | Destination Index   |
| 控制寄存器   | IP   | Instruction Pointer |
| 控制寄存器   | FLAG | Flag                |
| 段寄存器     | CS   | Code Segment        |
| 段寄存器     | DS   | Data Segment        |
| 段寄存器     | SS   | Stack Segment       |
| 段寄存器     | ES   | Extra Segment       |
*** 栈 bp, sp
1. sp 指向栈的顶端 stack pointer
2. bp 指向栈的基地址 base pointer
3. push 操作时, sp = sp - 2, bp 不变
4. pop 操作时, sp = sp + 2, bp 不变

#+BEGIN_SRC asm
  .code16                         ; 16 bits mode

  ;;; 初始化栈指针
  mov bp, 0x8000
  mov sp, bp                      ; sp = bp 时, 栈为空

  ;;; 压入 3 个测试数据
  ;;; sp = 0x8000, bp = 0x8000
  push 'A'
  ;;; sp = 0x7ffe, bp = 0x8000
  push 'B'
  ;;; sp = 0x7ffc, bp = 0x8000
  push 'C'

  ;;; 查看数据
  mov bx, bp
  mov al, [bx-2]
  int 0x10                        ; 打印 A

  mov bx, spp
  mov al, [bx]
  int 0x10                        ; 打印 C

  ;;; 弹出数据
  pop bx
  ;;; sp = 0x7ffc, bp = 0x8000
  mov al, bl
  int 0x10                        ; 打印 C

  pop bx
  ;;; sp = 0x7ffe, bp = 0x8000
  mov al, bl
  int 0x10                        ; 打印 B

  pop bx
  ;;; sp = 0x8000, bp = 0x8000
  mov al, bl
  int 0x10                        ; 打印 A
#+END_SRC

*** 分支
~jmp $~, $ 表示当前标号, 该指令会死循环

通常汇编的跳转通过 ~cmp~, ~je~, ~jmp~ 等指令配合实现，例如
#+BEGIN_SRC asm
  cmp ax, 4      ; if ax = 4
  je ax_is_four  ; do something (by jumping to that label)
  jmp else       ; else, do another thing
  jmp endif      ; finally, resume the normal flow

  ax_is_four:
      .....
      jmp endif

  else:
      .....
      jmp endif  ; not actually necessary but printed here for completeness

  endif:
#+END_SRC

函数调用也属于简单的跳转指令, 例如
#+BEGIN_SRC asm
  mov al, 'X'
  jmp print
  endprint:

  print:
      mov ah, 0x0e                ; tty code
      int 0x10                    ; 打印 al 的字符
      jmp endprint                ; 返回
#+END_SRC

由于函数调用非常常见, 会有一些指令来简化函数调用实现过程
#+BEGIN_SRC asm
  mov al, 'X'
  call print

  print:
      mov ah, 0x0e                ; tty code
      int 0x10                    ; 打印 al 的字符
      ret
#+END_SRC

*** 分段
8086 寄存器是 16 位的, 真实地址 = 段地址 << 4 + address
#+BEGIN_SRC asm
  ;;; 设置 ds 段寄存器
  mov bx, 0x7c0
  mov ds, bx
  ;;; 默认使用 ds 段寄存器作为基地址
  mov al, [msg]
  int 0x10

  ;;; 使用 es 段寄存器进行寻址
  mov bx, 0x7c0
  mov es, bx
  mov al, [es:the_secret]
  int 0x10
#+END_SRC
*** 磁盘
磁盘加载数据到内存采用 CHS 的寻址方式 (cylinder-head-sector), 读取磁盘的指令需要
将 ~al~ 设置成 ~0x02~ , 通过寄存器传入起始 CHS 地址和需要读取到的扇区数量，然后
调用中断 ~int 0x13~, 其中详细的中断参数见 [[https://stanislavs.org/helppc/int_13-2.html][link]]
#+BEGIN_SRC text
  AH = 02                                        读取操作的编码
  AL = number of sectors to read	(1-128 dec.)
  CH = track/cylinder number  (0-1023 dec., see below)
  CL = sector number  (1-17 dec.)
  DH = head number  (0-15 dec.)
  DL = drive number (0=A:, 1=2nd floppy, 80h=drive 0, 81h=drive 1)
  ES:BX = pointer to buffer                      数据装载的内存起始地址


  on return:
  AH = status  (see INT 13,STATUS)
  AL = number of sectors read
  CF = 0 if successful
     = 1 if error


  - BIOS disk reads should be retried at least three times and the
    controller should be reset upon error detection
  - be sure ES:BX does not cross a 64K segment boundary or a
    DMA boundary error will occur
  - many programming references list only floppy disk register values
  - only the disk number is checked for validity
  - the parameters in CX change depending on the number of cylinders;
    the track/cylinder number is a 10 bit value taken from the 2 high
    order bits of CL and the 8 bits in CH (low order 8 bits of track):

    |F|E|D|C|B|A|9|8|7|6|5-0|  CX
     | | | | | | | | | |	`-----	sector number
     | | | | | | | | `---------  high order 2 bits of track/cylinder
     `------------------------  low order 8 bits of track/cyl number
#+END_SRC

~carry bit~ 是用来记录操作是否溢出，例如
#+BEGIN_SRC asm
  mov ax, 0xFFFF
  add ax, 1                       ; ax = 0x0000 and carry = 1, 设置了溢出位
  jc label                        ; 如果溢出位设置了则跳转
#+END_SRC

加载磁盘数据的汇编代码
#+BEGIN_SRC asm
  ; load 'dh' sectors from drive 'dl' into ES:BX
  disk_load:
      pusha
      ; reading from disk requires setting specific values in all registers
      ; so we will overwrite our input parameters from 'dx'. Let's save it
      ; to the stack for later use.
      push dx

      mov ah, 0x02 ; ah <- int 0x13 function. 0x02 = 'read'
      mov al, dh   ; al <- number of sectors to read (0x01 .. 0x80)
      mov cl, 0x02 ; cl <- sector (0x01 .. 0x11)
                   ; 0x01 is our boot sector, 0x02 is the first 'available' sector
      mov ch, 0x00 ; ch <- cylinder (0x0 .. 0x3FF, upper 2 bits in 'cl')
      ; dl <- drive number. Our caller sets it as a parameter and gets it from BIOS
      ; (0 = floppy, 1 = floppy2, 0x80 = hdd, 0x81 = hdd2)
      mov dh, 0x00 ; dh <- head number (0x0 .. 0xF)

      ; [es:bx] <- pointer to buffer where the data will be stored
      ; caller sets it up for us, and it is actually the standard location for int 13h
      int 0x13      ; BIOS interrupt
      jc disk_error ; if error (stored in the carry bit)

      pop dx
      cmp al, dh    ; BIOS also sets 'al' to the # of sectors read. Compare it.
      jne sectors_error
      popa
      ret


  disk_error:
      mov bx, DISK_ERROR
      call print
      call print_nl
      mov dh, ah ; ah = error code, dl = disk drive that dropped the error
      call print_hex ; check out the code at http://stanislavs.org/helppc/int_13-1.html
      jmp disk_loop

  sectors_error:
      mov bx, SECTORS_ERROR
      call print

  disk_loop:
      jmp $

  DISK_ERROR: db "Disk read error", 0
  SECTORS_ERROR: db "Incorrect number of sectors read", 0
#+END_SRC
** 保护模式
*** 保护模式下的字符显示
1. 保护模式是 32 位运行的
2. 可以直接通过显存写入数据来显示字符
   - 显存地址 0xb8000
   - 一次显示需要两个参数，低 16 位传入字符, 高 16 位传入显示模式
#+BEGIN_SRC asm
  [bits 32] ; using 32-bit protected mode

  ; this is how constants are defined
  VIDEO_MEMORY equ 0xb8000
  WHITE_ON_BLACK equ 0x0f ; the color byte for each character

  print_string_pm:
      pusha
      mov edx, VIDEO_MEMORY

  print_string_pm_loop:
      mov al, [ebx] ; [ebx] is the address of our character
      mov ah, WHITE_ON_BLACK

      cmp al, 0 ; check if end of string
      je print_string_pm_done

      mov [edx], ax ; store character + attribute in video memory
      add ebx, 1 ; next char
      add edx, 2 ; next video memory position

      jmp print_string_pm_loop

  print_string_pm_done:
      popa
      ret
#+END_SRC

*** GDT
1. GDT 主要保护以下信息, 总共 64 位
   - base  = low(16) + middle(8) + high(8)
   - limit = low(16) + high(4)
   - flags = (12)
2. GDT 的第一项必须全是 ~0x00~
3. GDT 加载通过 ~lgdt~ 指令

下面是一个初始化的 gdt 内存定义，这里先将代码段和数据段合并在一起
#+BEGIN_SRC asm
  gdt_start: ; don't remove the labels, they're needed to compute sizes and jumps
      ; the GDT starts with a null 8-byte
      dd 0x0 ; 4 byte
      dd 0x0 ; 4 byte

  ; GDT for code segment. base = 0x00000000, length = 0xfffff
  gdt_code:
      dw 0xffff    ; segment length, bits 0-15                    | limit_low(16)
      dw 0x0       ; segment base, bits 0-15                      | base_low(16)
      db 0x0       ; segment base, bits 16-23                     | base_middle(8)
      db 10011010b ; flags (8 bits)                               | flags1(8)
      db 11001111b ; flags (4 bits) + segment length, bits 16-19  | limit_high(4), flags2(4)
      db 0x0       ; segment base, bits 24-31                     | base_high(8)

  gdt_data:
      dw 0xffff
      dw 0x0
      db 0x0
      db 10010010b
      db 11001111b
      db 0x0

  gdt_end:

  ; GDT descriptor, via lgdt [gdt_descriptor]
  gdt_descriptor:
      dw gdt_end - gdt_start - 1 ; size (16 bit), always one less of its true size
      dd gdt_start               ; address (32 bit)

  ; define some constants for later use
  CODE_SEG equ gdt_code - gdt_start
  DATA_SEG equ gdt_data - gdt_start
#+END_SRC

** 书籍及配套教材
1. 《x86 汇编语言：从实模式到保护模式》 [[http://www.lizhongc.com/index.php/archives/10/][book]] | [[https://www.bilibili.com/video/BV1xE411N74T/?spm_id_from=333.337.search-card.all.click&vd_source=3a56932406d5df288a20eff532848982][video]] | [[http://www.lizhongc.com/][李忠]]

* Linux 0.11
** MacOS
#+BEGIN_SRC sh
  brew install i386-elf-binutils i386-elf-gcc
#+END_SRC
